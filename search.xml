<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>一文详解JDK1.8的Lambda Stream LocalDateTime</title>
      <link href="/2024/02/25/%E4%B8%80%E6%96%87%E8%AF%A6%E8%A7%A3JDK1-8%E7%9A%84Lambda-Stream-LocalDateTime/"/>
      <url>/2024/02/25/%E4%B8%80%E6%96%87%E8%AF%A6%E8%A7%A3JDK1-8%E7%9A%84Lambda-Stream-LocalDateTime/</url>
      
        <content type="html"><![CDATA[<ul><li>转载自公众号 <a href="https://mp.weixin.qq.com/s/s_Scb0cNKK-KdxaZiholUw">JAVA日知录</a></li></ul><p>今天跟小伙伴们聊聊 Java中JDK1.8的一些新语法特性使用，主要是Lambda、Stream和LocalDate日期的一些使用讲解。</p><h2 id="Lambda"><a href="#Lambda" class="headerlink" title="Lambda"></a>Lambda</h2><h3 id="Lambda介绍"><a href="#Lambda介绍" class="headerlink" title="Lambda介绍"></a>Lambda介绍</h3><p>Lambda 表达式(lambda expression)是一个匿名函数，Lambda表达式基于数学中的λ演算得名，直接对应于其中的lambda抽象(lambda abstraction)，是一个匿名函数，即没有函数名的函数。</p><h3 id="Lambda表达式的结构"><a href="#Lambda表达式的结构" class="headerlink" title="Lambda表达式的结构"></a>Lambda表达式的结构</h3><p><strong>1. 一个 Lambda 表达式可以有零个或多个参数</strong></p><ul><li>参数的类型既可以明确声明，也可以根据上下文来推断。例如：(int a)与(a)效果相同</li><li>所有参数需包含在圆括号内，参数之间用逗号相隔。例如：(a, b) 或 (int a, int b) 或 (String a, int b, float c) 空圆括号代表参数集为空。例如：() -&gt; 42</li><li>当只有一个参数，且其类型可推导时，圆括号（）可省略。例如：a -&gt; return a*a</li></ul><p><strong>2.  Lambda 表达式的主体可包含零条或多条语句</strong></p><ul><li>如果 Lambda 表达式的主体只有一条语句，花括号{}可省略。匿名 函数的返回类型与该主体表达式一致</li><li>如果 Lambda 表达式的主体包含一条以上语句，则表达式必须包含在花括号{}中（形成代码块）。匿名函数的返回类型与代码块的返回类型一致，若没有返回则为空</li></ul><p><strong>3. Lambda 表达式的使用</strong></p><p>下面我们先使用一个简单的例子来看看Lambda的效果吧。</p><p>比如我们对Map 的遍历 传统方式遍历如下:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">  Map&lt;String, String&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">  map.put(<span class="string">&quot;a&quot;</span>, <span class="string">&quot;a&quot;</span>);</span><br><span class="line">  map.put(<span class="string">&quot;b&quot;</span>, <span class="string">&quot;b&quot;</span>);</span><br><span class="line">  map.put(<span class="string">&quot;c&quot;</span>, <span class="string">&quot;c&quot;</span>);</span><br><span class="line">  map.put(<span class="string">&quot;d&quot;</span>, <span class="string">&quot;d&quot;</span>);</span><br><span class="line"></span><br><span class="line">  System.out.println(<span class="string">&quot;map普通方式遍历:&quot;</span>);</span><br><span class="line">  <span class="keyword">for</span> (String key : map.keySet()) &#123;</span><br><span class="line">   System.out.println(<span class="string">&quot;k=&quot;</span> + key + <span class="string">&quot;，v=&quot;</span> + map.get(key));</span><br><span class="line">  &#125;</span><br><span class="line">使用Lambda进行遍历:</span><br><span class="line"></span><br><span class="line">  System.out.println(<span class="string">&quot;map拉姆达表达式遍历:&quot;</span>);</span><br><span class="line">  map.forEach((k, v) -&gt; &#123;</span><br><span class="line">   System.out.println(<span class="string">&quot;k=&quot;</span> + k + <span class="string">&quot;，v=&quot;</span> + v);</span><br><span class="line"> &#125;);</span><br><span class="line">List也同理，不过List还可以通过双冒号运算符遍历:</span><br><span class="line"></span><br><span class="line">  List&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;();</span><br><span class="line">  list.add(<span class="string">&quot;a&quot;</span>);</span><br><span class="line">  list.add(<span class="string">&quot;bb&quot;</span>);</span><br><span class="line">  list.add(<span class="string">&quot;ccc&quot;</span>);</span><br><span class="line">  list.add(<span class="string">&quot;dddd&quot;</span>);</span><br><span class="line">  System.out.println(<span class="string">&quot;list拉姆达表达式遍历:&quot;</span>);</span><br><span class="line">  list.forEach(v -&gt; &#123;</span><br><span class="line">   System.out.println(v);</span><br><span class="line">  &#125;);</span><br><span class="line">  System.out.println(<span class="string">&quot;list双冒号运算符遍历:&quot;</span>);</span><br><span class="line">  list.forEach(System.out::println);</span><br><span class="line">输出结果:</span><br><span class="line"></span><br><span class="line"> map普通方式遍历:</span><br><span class="line"> k=a，v=a</span><br><span class="line"> k=b，v=b</span><br><span class="line"> k=c，v=c</span><br><span class="line"> k=d，v=d</span><br><span class="line"> map拉姆达表达式遍历:</span><br><span class="line"> k=a，v=a</span><br><span class="line"> k=b，v=b</span><br><span class="line"> k=c，v=c</span><br><span class="line"> k=d，v=d</span><br><span class="line"> list拉姆达表达式遍历:</span><br><span class="line"> a</span><br><span class="line"> bb</span><br><span class="line"> ccc</span><br><span class="line"> dddd</span><br><span class="line"> list双冒号运算符遍历:</span><br><span class="line"> a</span><br><span class="line"> bb</span><br><span class="line"> ccc</span><br><span class="line"> dddd</span><br></pre></td></tr></table></figure><p><strong>4. Lambda 除了在for循环遍历中使用外，它还可以代替匿名的内部类。</strong></p><p>比如下面这个例子的线程创建:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用普通的方式创建</span></span><br><span class="line"><span class="type">Runnable</span> <span class="variable">r1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line"> <span class="meta">@Override</span></span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">  System.out.println(<span class="string">&quot;普通方式创建!&quot;</span>);</span><br><span class="line"> &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用拉姆达方式创建</span></span><br><span class="line"><span class="type">Runnable</span> <span class="variable">r2</span> <span class="operator">=</span> ()-&gt; System.out.println(<span class="string">&quot;拉姆达方式创建!&quot;</span>);</span><br></pre></td></tr></table></figure><p>注: 这个例子中使用Lambda表达式的时候，编译器会自动推断：根据线程类的构造函数签名 Runnable r { }，将该 Lambda 表达式赋 Runnable 接口。</p><p><strong>5. Lambda 表达式与匿名类的区别使用匿名类与 Lambda 表达式的一大区别在于关键词的使用。</strong></p><p>对于匿名类，关键词 this 解读为匿名类，而对于 Lambda 表达式，关键词 this 解读为写就 Lambda 的外部类。</p><p><strong>6. Lambda表达式使用注意事项</strong></p><p>Lambda虽然简化了代码的编写，但同时也减少了可读性。</p><p>Stream<br>Stream介绍<br>Stream 使用一种类似用 SQL 语句从数据库查询数据的直观方式来提供一种对 Java 集合运算和表达的高阶抽象。Stream API可以极大提高Java程序员的生产力，让程序员写出高效率、干净、简洁的代码。这种风格将要处理的元素集合看作一种流， 流在管道中传输， 并且可以在管道的节点上进行处理， 比如筛选， 排序，聚合等。</p><h2 id="Stream特性："><a href="#Stream特性：" class="headerlink" title="Stream特性："></a>Stream特性：</h2><ul><li>不是数据结构：它没有内部存储，它只是用操作管道从 source（数据结构、数组、generator function、IO channel）抓取数据。它也绝不修改自己所封装的底层数据结构的数据。例如 Stream 的 filter 操作会产生一个不包含被过滤元素的新 Stream，而不是从 source 删除那些元素。</li><li>不支持索引访问：但是很容易生成数组或者 List 。</li><li>惰性化：很多 Stream 操作是向后延迟的，一直到它弄清楚了最后需要多少数据才会开始。Intermediate 操作永远是惰性化的。</li><li>并行能力。当一个 Stream 是并行化的，就不需要再写多线程代码，所有对它的操作会自动并行进行的。</li><li>可以是无限的：集合有固定大小，Stream 则不必。limit(n) 和 findFirst() 这类的 short-circuiting 操作可以对无限的 Stream 进行运算并很快完成。</li><li>注意事项：所有 Stream 的操作必须以 lambda 表达式为参数。</li></ul><h3 id="Stream-流操作类型："><a href="#Stream-流操作类型：" class="headerlink" title="Stream 流操作类型："></a>Stream 流操作类型：</h3><ol><li>Intermediate：一个流可以后面跟随零个或多个 intermediate 操作。其目的主要是打开流，做出某种程度的数据映射&#x2F;过滤，然后返回一个新的流，交给下一个操作使用。这类操作都是惰性化的（lazy），就是说，仅仅调用到这类方法，并没有真正开始流的遍历。</li><li>Terminal：一个流只能有一个 terminal 操作，当这个操作执行后，流就被使用“光”了，无法再被操作。所以这必定是流的最后一个操作。Terminal操作的执行，才会真正开始流的遍历，并且会生成一个结果，或者一个 side effect。</li></ol><h3 id="Stream使用"><a href="#Stream使用" class="headerlink" title="Stream使用"></a>Stream使用</h3><p>这里我们依旧使用一个简单示例来看看吧。在开发中，我们有时需要对一些数据进行过滤，如果是传统的方式，我们需要对这批数据进行遍历过滤，会显得比较繁琐，如果使用steam流方式的话，那么可以很方便的进行处理。</p><p>首先通过普通的方式进行过滤:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; list = Arrays.asList(<span class="string">&quot;张三&quot;</span>, <span class="string">&quot;李四&quot;</span>, <span class="string">&quot;王五&quot;</span>, <span class="string">&quot;xuwujing&quot;</span>);</span><br><span class="line"> System.out.println(<span class="string">&quot;过滤之前:&quot;</span> + list);</span><br><span class="line"> List&lt;String&gt; result = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"> <span class="keyword">for</span> (String str : list) &#123;</span><br><span class="line">  <span class="keyword">if</span> (!<span class="string">&quot;李四&quot;</span>.equals(str)) &#123;</span><br><span class="line">   result.add(str);</span><br><span class="line">  &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> System.out.println(<span class="string">&quot;过滤之后:&quot;</span> + result);</span><br><span class="line">使用Steam方式进行过滤：</span><br><span class="line"></span><br><span class="line">List&lt;String&gt; result2 = list.stream().filter(str -&gt; !<span class="string">&quot;李四&quot;</span>.equals(str)).collect(Collectors.toList());</span><br><span class="line">System.out.println(<span class="string">&quot;stream 过滤之后:&quot;</span> + result2);</span><br><span class="line"></span><br><span class="line">输出结果:</span><br><span class="line"></span><br><span class="line">过滤之前:[张三, 李四, 王五, xuwujing]</span><br><span class="line">过滤之后:[张三, 王五, xuwujing]</span><br><span class="line">stream 过滤之后:[张三, 王五, xuwujing]</span><br></pre></td></tr></table></figure><p>是不是很简洁和方便呢。其实Stream流还有更多的使用方法，filter只是其中的一角而已。那么在这里我们就来学习了解下这些用法吧。</p><p><strong>1. 构造Stream流的方式</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Stream</span> <span class="variable">stream</span> <span class="operator">=</span> Stream.of(<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>, <span class="string">&quot;c&quot;</span>);</span><br><span class="line">String[] strArray = <span class="keyword">new</span> <span class="title class_">String</span>[] &#123; <span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>, <span class="string">&quot;c&quot;</span> &#125;;</span><br><span class="line">stream = Stream.of(strArray);</span><br><span class="line">stream = Arrays.stream(strArray);</span><br><span class="line">List&lt;String&gt; list = Arrays.asList(strArray);</span><br><span class="line">stream = list.stream();</span><br></pre></td></tr></table></figure><p><strong>2. Stream流的之间的转换</strong></p><p>注意:一个Stream流只可以使用一次，这段代码为了简洁而重复使用了数次，因此会抛出 stream has already been operated upon or closed 异常。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  Stream&lt;String&gt; stream2 = Stream.of(<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>, <span class="string">&quot;c&quot;</span>);</span><br><span class="line">  <span class="comment">// 转换成 Array</span></span><br><span class="line">  String[] strArray1 = stream2.toArray(String[]::<span class="keyword">new</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 转换成 Collection</span></span><br><span class="line">  List&lt;String&gt; list1 = stream2.collect(Collectors.toList());</span><br><span class="line">  List&lt;String&gt; list2 = stream2.collect(Collectors.toCollection(ArrayList::<span class="keyword">new</span>));   </span><br><span class="line">  <span class="type">Set</span> <span class="variable">set1</span> <span class="operator">=</span> stream2.collect(Collectors.toSet());</span><br><span class="line">  <span class="type">Stack</span> <span class="variable">stack1</span> <span class="operator">=</span> stream2.collect(Collectors.toCollection(Stack::<span class="keyword">new</span>));</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 转换成 String</span></span><br><span class="line">  <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> stream.collect(Collectors.joining()).toString();</span><br><span class="line"> &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">  e.printStackTrace();</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p><strong>3. Stream流的map使用</strong></p><p>map方法用于映射每个元素到对应的结果，一对一。</p><p>示例一：转换大写</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; list3 = Arrays.asList(<span class="string">&quot;zhangSan&quot;</span>, <span class="string">&quot;liSi&quot;</span>, <span class="string">&quot;wangWu&quot;</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;转换之前的数据:&quot;</span> + list3);</span><br><span class="line">List&lt;String&gt; list4 = list3.stream().map(String::toUpperCase).collect(Collectors.toList());</span><br><span class="line">System.out.println(<span class="string">&quot;转换之后的数据:&quot;</span> + list4); </span><br><span class="line"><span class="comment">// 转换之后的数据:[ZHANGSAN, LISI,WANGWU]</span></span><br></pre></td></tr></table></figure><p>示例二：转换数据类型</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; list31 = Arrays.asList(<span class="string">&quot;1&quot;</span>, <span class="string">&quot;2&quot;</span>, <span class="string">&quot;3&quot;</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;转换之前的数据:&quot;</span> + list31);</span><br><span class="line">List&lt;Integer&gt; list41 = list31.stream().map(Integer::valueOf).collect(Collectors.toList());</span><br><span class="line">System.out.println(<span class="string">&quot;转换之后的数据:&quot;</span> + list41); </span><br><span class="line"><span class="comment">// [1, 2, 3]</span></span><br></pre></td></tr></table></figure><p>示例三：获取平方</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; list5 = Arrays.asList(<span class="keyword">new</span> <span class="title class_">Integer</span>[] &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span> &#125;);</span><br><span class="line">List&lt;Integer&gt; list6 = list5.stream().map(n -&gt; n * n).collect(Collectors.toList());</span><br><span class="line">System.out.println(<span class="string">&quot;平方的数据:&quot;</span> + list6);</span><br><span class="line"><span class="comment">// [1, 4, 9, 16, 25]</span></span><br></pre></td></tr></table></figure><p><strong>4. Stream流的filter使用</strong></p><p>filter方法用于通过设置的条件过滤出元素。</p><p>示例二：通过与 findAny 得到 if&#x2F;else 的值</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; list = Arrays.asList(<span class="string">&quot;张三&quot;</span>, <span class="string">&quot;李四&quot;</span>, <span class="string">&quot;王五&quot;</span>, <span class="string">&quot;xuwujing&quot;</span>);</span><br><span class="line"><span class="type">String</span> <span class="variable">result3</span> <span class="operator">=</span> list.stream().filter(str -&gt; <span class="string">&quot;李四&quot;</span>.equals(str)).findAny().orElse(<span class="string">&quot;找不到!&quot;</span>);</span><br><span class="line"><span class="type">String</span> <span class="variable">result4</span> <span class="operator">=</span> list.stream().filter(str -&gt; <span class="string">&quot;李二&quot;</span>.equals(str)).findAny().orElse(<span class="string">&quot;找不到!&quot;</span>);</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">&quot;stream 过滤之后 2:&quot;</span> + result3);</span><br><span class="line">System.out.println(<span class="string">&quot;stream 过滤之后 3:&quot;</span> + result4);</span><br><span class="line"><span class="comment">//stream 过滤之后 2:李四</span></span><br><span class="line"><span class="comment">//stream 过滤之后 3:找不到!</span></span><br></pre></td></tr></table></figure><p>示例三：通过与 mapToInt 计算和</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">List&lt;User&gt; lists = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;User&gt;();</span><br><span class="line">lists.add(<span class="keyword">new</span> <span class="title class_">User</span>(<span class="number">6</span>, <span class="string">&quot;张三&quot;</span>));</span><br><span class="line">lists.add(<span class="keyword">new</span> <span class="title class_">User</span>(<span class="number">2</span>, <span class="string">&quot;李四&quot;</span>));</span><br><span class="line">lists.add(<span class="keyword">new</span> <span class="title class_">User</span>(<span class="number">3</span>, <span class="string">&quot;王五&quot;</span>));</span><br><span class="line">lists.add(<span class="keyword">new</span> <span class="title class_">User</span>(<span class="number">1</span>, <span class="string">&quot;张三&quot;</span>));</span><br><span class="line"><span class="comment">// 计算这个list中出现 &quot;张三&quot; id的值</span></span><br><span class="line"><span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> lists.stream().filter(u -&gt; <span class="string">&quot;张三&quot;</span>.equals(u.getName())).mapToInt(u -&gt; u.getId()).sum();</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">&quot;计算结果:&quot;</span> + sum); </span><br><span class="line"><span class="comment">// 7</span></span><br></pre></td></tr></table></figure><p><strong>5. Stream 流的 flatMap 使用</strong></p><p>flatMap 方法用于映射每个元素到对应的结果，一对多。</p><p>示例:从句子中得到单词</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">worlds</span> <span class="operator">=</span> <span class="string">&quot;The way of the future&quot;</span>;</span><br><span class="line">List&lt;String&gt; list7 = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">list7.add(worlds);</span><br><span class="line">List&lt;String&gt; list8 = list7.stream().flatMap(str -&gt; Stream.of(str.split(<span class="string">&quot; &quot;</span>)))</span><br><span class="line">  .filter(world -&gt; world.length() &gt; <span class="number">0</span>).collect(Collectors.toList());</span><br><span class="line">System.out.println(<span class="string">&quot;单词:&quot;</span>);</span><br><span class="line">list8.forEach(System.out::println);</span><br><span class="line"><span class="comment">// 单词:</span></span><br><span class="line"><span class="comment">// The </span></span><br><span class="line"><span class="comment">// way </span></span><br><span class="line"><span class="comment">// of </span></span><br><span class="line"><span class="comment">// the </span></span><br><span class="line"><span class="comment">// future</span></span><br></pre></td></tr></table></figure><p><strong>6. Stream流的limit使用</strong></p><p>limit 方法用于获取指定数量的流。</p><p>示例一：获取前n条数的数据</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Random</span> <span class="variable">rd</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>();</span><br><span class="line">System.out.println(<span class="string">&quot;取到的前三条数据:&quot;</span>);</span><br><span class="line">rd.ints().limit(<span class="number">3</span>).forEach(System.out::println);</span><br><span class="line"><span class="comment">// 取到的前三条数据:</span></span><br><span class="line"><span class="comment">// 1167267754</span></span><br><span class="line"><span class="comment">// -1164558977</span></span><br><span class="line"><span class="comment">// 1977868798</span></span><br></pre></td></tr></table></figure><p>示例二：结合skip使用得到需要的数据</p><p>skip表示的是扔掉前n个元素。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">List&lt;User&gt; list9 = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;User&gt;();</span><br><span class="line"> <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">  <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>(i, <span class="string">&quot;pancm&quot;</span> + i);</span><br><span class="line">  list9.add(user);</span><br><span class="line"> &#125;</span><br><span class="line"> System.out.println(<span class="string">&quot;截取之前的数据:&quot;</span>);</span><br><span class="line"> <span class="comment">// 取前3条数据，但是扔掉了前面的2条，可以理解为拿到的数据为 2&lt;=i&lt;3 (i 是数值下标)</span></span><br><span class="line"> List&lt;String&gt; list10 = list9.stream().map(User::getName).limit(<span class="number">3</span>).skip(<span class="number">2</span>).collect(Collectors.toList());</span><br><span class="line"> System.out.println(<span class="string">&quot;截取之后的数据:&quot;</span> + list10);</span><br><span class="line"> <span class="comment">//  截取之前的数据:</span></span><br><span class="line"> <span class="comment">//  姓名:pancm1</span></span><br><span class="line"> <span class="comment">//  姓名:pancm2</span></span><br><span class="line"> <span class="comment">//  姓名:pancm3</span></span><br><span class="line"> <span class="comment">//  截取之后的数据:[pancm3]</span></span><br></pre></td></tr></table></figure><p>注: User实体类中 getName 方法会打印姓名。</p><p><strong>7. Stream流的sort使用</strong></p><p>sorted方法用于对流进行升序排序。</p><p>示例一：随机取值排序</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Random</span> <span class="variable">rd2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>();</span><br><span class="line">System.out.println(<span class="string">&quot;取到的前三条数据然后进行排序:&quot;</span>);</span><br><span class="line">rd2.ints().limit(<span class="number">3</span>).sorted().forEach(System.out::println);</span><br><span class="line"><span class="comment">// 取到的前三条数据然后进行排序:</span></span><br><span class="line"><span class="comment">// -2043456377</span></span><br><span class="line"><span class="comment">// -1778595703</span></span><br><span class="line"><span class="comment">// 1013369565</span></span><br></pre></td></tr></table></figure><p>示例二：优化排序</p><p>&#x3D;&#x3D;tips&#x3D;&#x3D;: 先获取在排序效率会更高!</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//普通的排序取值</span></span><br><span class="line">List&lt;User&gt; list11 = list9.stream().sorted((u1, u2) -&gt; u1.getName().compareTo(u2.getName())).limit(<span class="number">3</span>)</span><br><span class="line">  .collect(Collectors.toList());</span><br><span class="line">System.out.println(<span class="string">&quot;排序之后的数据:&quot;</span> + list11);</span><br><span class="line"><span class="comment">//优化排序取值</span></span><br><span class="line">List&lt;User&gt; list12 = list9.stream().limit(<span class="number">3</span>).sorted((u1, u2) -&gt; u1.getName().compareTo(u2.getName()))</span><br><span class="line">  .collect(Collectors.toList());</span><br><span class="line">System.out.println(<span class="string">&quot;优化排序之后的数据:&quot;</span> + list12);</span><br><span class="line"><span class="comment">//排序之后的数据:[&#123;&quot;id&quot;:1,&quot;name&quot;:&quot;pancm1&quot;&#125;, &#123;&quot;id&quot;:2,&quot;name&quot;:&quot;pancm2&quot;&#125;, &#123;&quot;id&quot;:3,&quot;name&quot;:&quot;pancm3&quot;&#125;]</span></span><br><span class="line"><span class="comment">//优化排序之后的数据:[&#123;&quot;id&quot;:1,&quot;name&quot;:&quot;pancm1&quot;&#125;, &#123;&quot;id&quot;:2,&quot;name&quot;:&quot;pancm2&quot;&#125;, &#123;&quot;id&quot;:3,&quot;name&quot;:&quot;pancm3&quot;&#125;]</span></span><br></pre></td></tr></table></figure><p><strong>8. Stream流的peek使用</strong></p><p>peek对每个元素执行操作并返回一个新的Stream</p><p>示例: 双重操作</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(<span class="string">&quot;peek使用:&quot;</span>);</span><br><span class="line">Stream.of(<span class="string">&quot;one&quot;</span>, <span class="string">&quot;two&quot;</span>, <span class="string">&quot;three&quot;</span>, <span class="string">&quot;four&quot;</span>).filter(e -&gt; e.length() &gt; <span class="number">3</span>).peek(e -&gt; System.out.println(<span class="string">&quot;转换之前: &quot;</span> + e))</span><br><span class="line">  .map(String::toUpperCase).peek(e -&gt; System.out.println(<span class="string">&quot;转换之后: &quot;</span> + e)).collect(Collectors.toList());</span><br><span class="line"></span><br><span class="line"><span class="comment">// 转换之前: three</span></span><br><span class="line"><span class="comment">// 转换之后: THREE</span></span><br><span class="line"><span class="comment">// 转换之前: four</span></span><br><span class="line"><span class="comment">// 转换之后: FOUR</span></span><br></pre></td></tr></table></figure><p><strong>9. Stream流的parallel使用</strong></p><p>parallelStream 是流并行处理程序的代替方法。</p><p>示例:获取空字符串的数量</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; strings = Arrays.asList(<span class="string">&quot;a&quot;</span>, <span class="string">&quot;&quot;</span>, <span class="string">&quot;c&quot;</span>, <span class="string">&quot;&quot;</span>, <span class="string">&quot;e&quot;</span>,<span class="string">&quot;&quot;</span>, <span class="string">&quot; &quot;</span>);</span><br><span class="line"><span class="comment">// 获取空字符串的数量</span></span><br><span class="line"><span class="type">long</span> <span class="variable">count</span> <span class="operator">=</span>  strings.parallelStream().filter(string -&gt; string.isEmpty()).count();</span><br><span class="line">System.out.println(<span class="string">&quot;空字符串的个数:&quot;</span>+count);</span><br></pre></td></tr></table></figure><p><strong>10. Stream流的max&#x2F;min&#x2F;distinct使用</strong></p><p>示例一：得到最大最小值</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; list13 = Arrays.asList(<span class="string">&quot;zhangsan&quot;</span>,<span class="string">&quot;lisi&quot;</span>,<span class="string">&quot;wangwu&quot;</span>,<span class="string">&quot;xuwujing&quot;</span>);</span><br><span class="line"><span class="type">int</span> <span class="variable">maxLines</span> <span class="operator">=</span> list13.stream().mapToInt(String::length).max().getAsInt();</span><br><span class="line"><span class="type">int</span> <span class="variable">minLines</span> <span class="operator">=</span> list13.stream().mapToInt(String::length).min().getAsInt();</span><br><span class="line">System.out.println(<span class="string">&quot;最长字符的长度:&quot;</span> + maxLines+<span class="string">&quot;,最短字符的长度:&quot;</span>+minLines);</span><br><span class="line"><span class="comment">//最长字符的长度:8,最短字符的长度:4</span></span><br></pre></td></tr></table></figure><p>示例二：得到去重之后的数据</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">lines</span> <span class="operator">=</span> <span class="string">&quot;good good study day day up&quot;</span>;</span><br><span class="line">List&lt;String&gt; list14 = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;();</span><br><span class="line">list14.add(lines);</span><br><span class="line">List&lt;String&gt; words = list14.stream().flatMap(line -&gt; Stream.of(line.split(<span class="string">&quot; &quot;</span>))).filter(word -&gt; word.length() &gt; <span class="number">0</span>)</span><br><span class="line">  .map(String::toLowerCase).distinct().sorted().collect(Collectors.toList());</span><br><span class="line">System.out.println(<span class="string">&quot;去重复之后:&quot;</span> + words);</span><br><span class="line"><span class="comment">//去重复之后:[day, good, study, up]</span></span><br></pre></td></tr></table></figure><p><strong>11. Stream流的Match使用</strong></p><ul><li>allMatch：Stream 中全部元素符合则返回 true ;</li><li>anyMatch：Stream 中只要有一个元素符合则返回 true;</li><li>noneMatch：Stream 中没有一个元素符合则返回 true。</li></ul><p>示例:数据是否符合</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">boolean</span> <span class="variable">all</span> <span class="operator">=</span> lists.stream().allMatch(u -&gt; u.getId() &gt; <span class="number">3</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;是否都大于3:&quot;</span> + all);</span><br><span class="line"><span class="type">boolean</span> <span class="variable">any</span> <span class="operator">=</span> lists.stream().anyMatch(u -&gt; u.getId() &gt; <span class="number">3</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;是否有一个大于3:&quot;</span> + any);</span><br><span class="line"><span class="type">boolean</span> <span class="variable">none</span> <span class="operator">=</span> lists.stream().noneMatch(u -&gt; u.getId() &gt; <span class="number">3</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;是否没有一个大于3的:&quot;</span> + none);  </span><br><span class="line"><span class="comment">// 是否都大于3:false</span></span><br><span class="line"><span class="comment">// 是否有一个大于3:true</span></span><br><span class="line"><span class="comment">// 是否没有一个大于3的:false</span></span><br></pre></td></tr></table></figure><p><strong>12. Stream流的reduce使用</strong></p><p>reduce 主要作用是把 Stream 元素组合起来进行操作。</p><p>示例一：字符串连接</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">concat</span> <span class="operator">=</span> Stream.of(<span class="string">&quot;A&quot;</span>, <span class="string">&quot;B&quot;</span>, <span class="string">&quot;C&quot;</span>, <span class="string">&quot;D&quot;</span>).reduce(<span class="string">&quot;&quot;</span>, String::concat);</span><br><span class="line">System.out.println(<span class="string">&quot;字符串拼接:&quot;</span> + concat);</span><br></pre></td></tr></table></figure><p>示例二：得到最小值</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">double</span> <span class="variable">minValue</span> <span class="operator">=</span> Stream.of(-<span class="number">4.0</span>, <span class="number">1.0</span>, <span class="number">3.0</span>, -<span class="number">2.0</span>).reduce(Double.MAX_VALUE, Double::min);</span><br><span class="line">System.out.println(<span class="string">&quot;最小值:&quot;</span> + minValue);</span><br><span class="line"><span class="comment">//最小值:-4.0</span></span><br></pre></td></tr></table></figure><p>示例三：求和</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 求和, 无起始值</span></span><br><span class="line"><span class="type">int</span> <span class="variable">sumValue</span> <span class="operator">=</span> Stream.of(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>).reduce(Integer::sum).get();</span><br><span class="line">System.out.println(<span class="string">&quot;有无起始值求和:&quot;</span> + sumValue);</span><br><span class="line"><span class="comment">// 求和, 有起始值</span></span><br><span class="line"> sumValue = Stream.of(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>).reduce(<span class="number">1</span>, Integer::sum);</span><br><span class="line"> System.out.println(<span class="string">&quot;有起始值求和:&quot;</span> + sumValue);</span><br><span class="line"><span class="comment">// 有无起始值求和:10</span></span><br><span class="line"><span class="comment">// 有起始值求和:11</span></span><br></pre></td></tr></table></figure><p>示例四：过滤拼接</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">concat = Stream.of(<span class="string">&quot;a&quot;</span>, <span class="string">&quot;B&quot;</span>, <span class="string">&quot;c&quot;</span>, <span class="string">&quot;D&quot;</span>, <span class="string">&quot;e&quot;</span>, <span class="string">&quot;F&quot;</span>).filter(x -&gt; x.compareTo(<span class="string">&quot;Z&quot;</span>) &gt; <span class="number">0</span>).reduce(<span class="string">&quot;&quot;</span>, String::concat);</span><br><span class="line">System.out.println(<span class="string">&quot;过滤和字符串连接:&quot;</span> + concat);</span><br><span class="line"> <span class="comment">//过滤和字符串连接:ace</span></span><br></pre></td></tr></table></figure><p><strong>13.Stream流的iterate使用</strong></p><p>iterate 跟 reduce 操作很像，接受一个种子值，和一个UnaryOperator（例如 f）。然后种子值成为 Stream 的第一个元素，f(seed) 为第二个，f(f(seed)) 第三个，以此类推。在 iterate 时候管道必须有 limit 这样的操作来限制 Stream 大小。</p><p>示例:生成一个等差队列</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(<span class="string">&quot;从2开始生成一个等差队列:&quot;</span>);</span><br><span class="line">Stream.iterate(<span class="number">2</span>, n -&gt; n + <span class="number">2</span>).limit(<span class="number">5</span>).forEach(x -&gt; System.out.print(x + <span class="string">&quot; &quot;</span>));</span><br><span class="line"><span class="comment">// 从2开始生成一个等差队列:</span></span><br><span class="line"><span class="comment">// 2 4 6 8 10</span></span><br></pre></td></tr></table></figure><p><strong>14.Stream流的 Supplier 使用</strong></p><p>通过实现Supplier类的方法可以自定义流计算规则。</p><p>示例：随机获取两条用户信息</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"> System.out.println(<span class="string">&quot;自定义一个流进行计算输出:&quot;</span>);</span><br><span class="line"> Stream.generate(<span class="keyword">new</span> <span class="title class_">UserSupplier</span>()).limit(<span class="number">2</span>).forEach(u -&gt; System.out.println(u.getId() + <span class="string">&quot;, &quot;</span> + u.getName()));</span><br><span class="line"> </span><br><span class="line"> <span class="comment">//第一次:</span></span><br><span class="line"> <span class="comment">//自定义一个流进行计算输出:</span></span><br><span class="line"> <span class="comment">//10, pancm7</span></span><br><span class="line"> <span class="comment">//11, pancm6</span></span><br><span class="line"> </span><br><span class="line"> <span class="comment">//第二次:</span></span><br><span class="line"> <span class="comment">//自定义一个流进行计算输出:</span></span><br><span class="line"> <span class="comment">//10, pancm4</span></span><br><span class="line"> <span class="comment">//11, pancm2</span></span><br><span class="line"> </span><br><span class="line"> <span class="comment">//第三次:</span></span><br><span class="line"> <span class="comment">//自定义一个流进行计算输出:</span></span><br><span class="line"> <span class="comment">//10, pancm4</span></span><br><span class="line"> <span class="comment">//11, pancm8</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">UserSupplier</span> <span class="keyword">implements</span> <span class="title class_">Supplier</span>&lt;User&gt; &#123;</span><br><span class="line"> <span class="keyword">private</span> <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"> <span class="keyword">private</span> <span class="type">Random</span> <span class="variable">random</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>();</span><br><span class="line"></span><br><span class="line"> <span class="meta">@Override</span></span><br><span class="line"> <span class="keyword">public</span> User <span class="title function_">get</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">User</span>(index++, <span class="string">&quot;pancm&quot;</span> + random.nextInt(<span class="number">10</span>));</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>15.Stream流的groupingBy&#x2F;partitioningBy使用</strong></p><ul><li>groupingBy：分组排序；</li><li>partitioningBy：分区排序。</li></ul><p>示例一：分组排序</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(<span class="string">&quot;通过id进行分组排序:&quot;</span>);</span><br><span class="line">Map&lt;Integer, List&lt;User&gt;&gt; personGroups = Stream.generate(<span class="keyword">new</span> <span class="title class_">UserSupplier2</span>()).limit(<span class="number">5</span>)</span><br><span class="line">  .collect(Collectors.groupingBy(User::getId));</span><br><span class="line"><span class="type">Iterator</span> <span class="variable">it</span> <span class="operator">=</span> personGroups.entrySet().iterator();</span><br><span class="line"><span class="keyword">while</span> (it.hasNext()) &#123;</span><br><span class="line"> Map.Entry&lt;Integer, List&lt;User&gt;&gt; persons = (Map.Entry) it.next();</span><br><span class="line"> System.out.println(<span class="string">&quot;id &quot;</span> + persons.getKey() + <span class="string">&quot; = &quot;</span> + persons.getValue());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过id进行分组排序:</span></span><br><span class="line"><span class="comment">// id 10 = [&#123;&quot;id&quot;:10,&quot;name&quot;:&quot;pancm1&quot;&#125;] </span></span><br><span class="line"><span class="comment">// id 11 = [&#123;&quot;id&quot;:11,&quot;name&quot;:&quot;pancm3&quot;&#125;, &#123;&quot;id&quot;:11,&quot;name&quot;:&quot;pancm6&quot;&#125;, &#123;&quot;id&quot;:11,&quot;name&quot;:&quot;pancm4&quot;&#125;, &#123;&quot;id&quot;:11,&quot;name&quot;:&quot;pancm7&quot;&#125;]</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">UserSupplier2</span> <span class="keyword">implements</span> <span class="title class_">Supplier</span>&lt;User&gt; &#123;</span><br><span class="line"> <span class="keyword">private</span> <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"> <span class="keyword">private</span> <span class="type">Random</span> <span class="variable">random</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>();</span><br><span class="line"></span><br><span class="line"> <span class="meta">@Override</span></span><br><span class="line"> <span class="keyword">public</span> User <span class="title function_">get</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">User</span>(index % <span class="number">2</span> == <span class="number">0</span> ? index++ : index, <span class="string">&quot;pancm&quot;</span> + random.nextInt(<span class="number">10</span>));</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>示例二：分区排序</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">   System.out.println(<span class="string">&quot;通过年龄进行分区排序:&quot;</span>);</span><br><span class="line">Map&lt;Boolean, List&lt;User&gt;&gt; children = Stream.generate(<span class="keyword">new</span> <span class="title class_">UserSupplier3</span>()).limit(<span class="number">5</span>)</span><br><span class="line">  .collect(Collectors.partitioningBy(p -&gt; p.getId() &lt; <span class="number">18</span>));</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">&quot;小孩: &quot;</span> + children.get(<span class="literal">true</span>));</span><br><span class="line">System.out.println(<span class="string">&quot;成年人: &quot;</span> + children.get(<span class="literal">false</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过年龄进行分区排序:</span></span><br><span class="line"><span class="comment">// 小孩: [&#123;&quot;id&quot;:16,&quot;name&quot;:&quot;pancm7&quot;&#125;, &#123;&quot;id&quot;:17,&quot;name&quot;:&quot;pancm2&quot;&#125;]</span></span><br><span class="line"><span class="comment">// 成年人: [&#123;&quot;id&quot;:18,&quot;name&quot;:&quot;pancm4&quot;&#125;, &#123;&quot;id&quot;:19,&quot;name&quot;:&quot;pancm9&quot;&#125;, &#123;&quot;id&quot;:20,&quot;name&quot;:&quot;pancm6&quot;&#125;]</span></span><br><span class="line"></span><br><span class="line"> <span class="keyword">class</span> <span class="title class_">UserSupplier3</span> <span class="keyword">implements</span> <span class="title class_">Supplier</span>&lt;User&gt; &#123;</span><br><span class="line"> <span class="keyword">private</span> <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> <span class="number">16</span>;</span><br><span class="line"> <span class="keyword">private</span> <span class="type">Random</span> <span class="variable">random</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>();</span><br><span class="line"></span><br><span class="line"> <span class="meta">@Override</span></span><br><span class="line"> <span class="keyword">public</span> User <span class="title function_">get</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">User</span>(index++, <span class="string">&quot;pancm&quot;</span> + random.nextInt(<span class="number">10</span>));</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>16.Stream流的summaryStatistics使用</p><p>IntSummaryStatistics 用于收集统计信息(如count、min、max、sum和average)的状态对象。</p><p>示例:得到最大、最小、之和以及平均数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; numbers = Arrays.asList(<span class="number">1</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">3</span>, <span class="number">9</span>);</span><br><span class="line"><span class="type">IntSummaryStatistics</span> <span class="variable">stats</span> <span class="operator">=</span> numbers.stream().mapToInt((x) -&gt; x).summaryStatistics();</span><br><span class="line"> </span><br><span class="line">System.out.println(<span class="string">&quot;列表中最大的数 : &quot;</span> + stats.getMax());</span><br><span class="line">System.out.println(<span class="string">&quot;列表中最小的数 : &quot;</span> + stats.getMin());</span><br><span class="line">System.out.println(<span class="string">&quot;所有数之和 : &quot;</span> + stats.getSum());</span><br><span class="line">System.out.println(<span class="string">&quot;平均数 : &quot;</span> + stats.getAverage());</span><br><span class="line"></span><br><span class="line"><span class="comment">// 列表中最大的数 : 9</span></span><br><span class="line"><span class="comment">// 列表中最小的数 : 1</span></span><br><span class="line"><span class="comment">// 所有数之和 : 25</span></span><br><span class="line"><span class="comment">// 平均数 : 5.0</span></span><br></pre></td></tr></table></figure><p>Stream 介绍就到这里了，JDK1.8中的Stream流其实还有很多很多用法，更多的用法则需要大家去查看JDK1.8的API文档了。</p><h2 id="LocalDateTime"><a href="#LocalDateTime" class="headerlink" title="LocalDateTime"></a>LocalDateTime</h2><h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p>JDK1.8除了新增了lambda表达式、stream流之外，它还新增了全新的日期时间API。在JDK1.8之前，Java处理日期、日历和时间的方式一直为社区所诟病，将 java.util.Date设定为可变类型，以及SimpleDateFormat的非线程安全使其应用非常受限。因此推出了java.time包，该包下的所有类都是不可变类型而且线程安全。</p><h3 id="关键类"><a href="#关键类" class="headerlink" title="关键类"></a>关键类</h3><ul><li>Instant：瞬时时间。</li><li>LocalDate：本地日期，不包含具体时间, 格式 yyyy-MM-dd。</li><li>LocalTime：本地时间，不包含日期. 格式 yyyy-MM-dd HH:mm:ss.SSS 。</li><li>LocalDateTime：组合了日期和时间，但不包含时差和时区信息。</li><li>ZonedDateTime：最完整的日期时间，包含时区和相对UTC或格林威治的时差。<br>使用</li></ul><p><strong>1.获取当前的日期时间</strong></p><p>通过静态工厂方法now()来获取当前时间。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//本地日期,不包括时分秒</span></span><br><span class="line"><span class="type">LocalDate</span> <span class="variable">nowDate</span> <span class="operator">=</span> LocalDate.now();</span><br><span class="line"><span class="comment">//本地日期,包括时分秒</span></span><br><span class="line"><span class="type">LocalDateTime</span> <span class="variable">nowDateTime</span> <span class="operator">=</span> LocalDateTime.now();</span><br><span class="line">System.out.println(<span class="string">&quot;当前时间:&quot;</span>+nowDate);</span><br><span class="line">System.out.println(<span class="string">&quot;当前时间:&quot;</span>+nowDateTime);</span><br><span class="line"><span class="comment">//  当前时间:2018-12-19</span></span><br><span class="line"><span class="comment">//  当前时间:2018-12-19T15:24:35.822</span></span><br></pre></td></tr></table></figure><p><strong>2.获取当前的年月日时分秒</strong></p><p>获取时间之后，直接get获取年月日时分秒。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">//获取当前的时间，包括毫秒</span></span><br><span class="line"> <span class="type">LocalDateTime</span> <span class="variable">ldt</span> <span class="operator">=</span> LocalDateTime.now();</span><br><span class="line"> System.out.println(<span class="string">&quot;当前年:&quot;</span>+ldt.getYear());   <span class="comment">//2018</span></span><br><span class="line"> System.out.println(<span class="string">&quot;当前年份天数:&quot;</span>+ldt.getDayOfYear());<span class="comment">//172 </span></span><br><span class="line"> System.out.println(<span class="string">&quot;当前月:&quot;</span>+ldt.getMonthValue());</span><br><span class="line"> System.out.println(<span class="string">&quot;当前时:&quot;</span>+ldt.getHour());</span><br><span class="line"> System.out.println(<span class="string">&quot;当前分:&quot;</span>+ldt.getMinute());</span><br><span class="line"> System.out.println(<span class="string">&quot;当前时间:&quot;</span>+ldt.toString());</span><br><span class="line"><span class="comment">//   当前年:2018</span></span><br><span class="line"><span class="comment">//   当前年份天数:353</span></span><br><span class="line"><span class="comment">//   当前月:12</span></span><br><span class="line"><span class="comment">//   当前时:15</span></span><br><span class="line"><span class="comment">//   当前分:24</span></span><br><span class="line"><span class="comment">//   当前时间:2018-12-19T15:24:35.833</span></span><br></pre></td></tr></table></figure><p><strong>3.格式化时间</strong></p><p>格式时间格式需要用到DateTimeFormatter类。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">LocalDateTime</span> <span class="variable">ldt</span> <span class="operator">=</span> LocalDateTime.now();</span><br><span class="line">System.out.println(<span class="string">&quot;格式化时间: &quot;</span>+ ldt.format(DateTimeFormatter.ofPattern(<span class="string">&quot;yyyy-MM-dd HH:mm:ss.SSS&quot;</span>)));</span><br><span class="line"><span class="comment">//格式化时间:2018-12-19 15:37:47.119</span></span><br></pre></td></tr></table></figure><p>4.时间增减</p><p>在指定的时间进行增加&#x2F;减少年月日时分秒。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"> <span class="type">LocalDateTime</span> <span class="variable">ldt</span> <span class="operator">=</span> LocalDateTime.now();</span><br><span class="line"> System.out.println(<span class="string">&quot;后5天时间:&quot;</span>+ldt.plusDays(<span class="number">5</span>));</span><br><span class="line"> System.out.println(<span class="string">&quot;前5天时间并格式化:&quot;</span>+ldt.minusDays(<span class="number">5</span>).format(DateTimeFormatter.ofPattern(<span class="string">&quot;yyyy-MM-dd&quot;</span>))); <span class="comment">//2018-06-16</span></span><br><span class="line"> System.out.println(<span class="string">&quot;前一个月的时间:&quot;</span>+ldt2.minusMonths(<span class="number">1</span>).format(DateTimeFormatter.ofPattern(<span class="string">&quot;yyyyMM&quot;</span>))); <span class="comment">//2018-06-16</span></span><br><span class="line"> System.out.println(<span class="string">&quot;后一个月的时间:&quot;</span>+ldt2.plusMonths(<span class="number">1</span>)); <span class="comment">//2018-06-16</span></span><br><span class="line"> System.out.println(<span class="string">&quot;指定2099年的当前时间:&quot;</span>+ldt.withYear(<span class="number">2099</span>)); <span class="comment">//2099-06-21T15:07:39.506</span></span><br><span class="line"><span class="comment">//  后5天时间:2018-12-24T15:50:37.508</span></span><br><span class="line"><span class="comment">//  前5天时间并格式化:2018-12-14</span></span><br><span class="line"><span class="comment">//  前一个月的时间:201712</span></span><br><span class="line"><span class="comment">//  后一个月的时间:2018-02-04T09:19:29.499</span></span><br><span class="line"><span class="comment">//  指定2099年的当前时间:2099-12-19T15:50:37.508</span></span><br></pre></td></tr></table></figure><p>5.创建指定时间</p><p>通过指定年月日来创建。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">LocalDate ld3=LocalDate.of(<span class="number">2017</span>, Month.NOVEMBER, <span class="number">17</span>);</span><br><span class="line">LocalDate ld4=LocalDate.of(<span class="number">2018</span>, <span class="number">02</span>, <span class="number">11</span>);</span><br></pre></td></tr></table></figure><p><strong>6.时间相差比较</strong></p><p>比较相差的年月日时分秒。</p><p>示例一: 具体相差的年月日</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">LocalDate ld=LocalDate.parse(<span class="string">&quot;2017-11-17&quot;</span>);</span><br><span class="line">LocalDate ld2=LocalDate.parse(<span class="string">&quot;2018-01-05&quot;</span>);</span><br><span class="line">Period p=Period.between(ld, ld2);</span><br><span class="line">System.out.println(<span class="string">&quot;相差年: &quot;</span>+p.getYears()+<span class="string">&quot; 相差月 :&quot;</span>+p.getMonths() +<span class="string">&quot; 相差天:&quot;</span>+p.getDays());</span><br><span class="line"><span class="comment">// 相差年: 0 相差月 :1 相差天:19</span></span><br></pre></td></tr></table></figure><p><strong>注:</strong> 这里的月份是不满足一年，天数是不满足一个月的。这里实际相差的是1月19天，也就是49天。</p><p>示例二：相差总数的时间</p><p>ChronoUnit 日期周期单位的标准集合。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">  <span class="type">LocalDate</span> <span class="variable">startDate</span> <span class="operator">=</span> LocalDate.of(<span class="number">2017</span>, <span class="number">11</span>, <span class="number">17</span>);</span><br><span class="line">      <span class="type">LocalDate</span> <span class="variable">endDate</span> <span class="operator">=</span> LocalDate.of(<span class="number">2018</span>, <span class="number">01</span>, <span class="number">05</span>);</span><br><span class="line">      System.out.println(<span class="string">&quot;相差月份:&quot;</span>+ChronoUnit.MONTHS.between(startDate, endDate));</span><br><span class="line">      System.out.println(<span class="string">&quot;两月之间的相差的天数   : &quot;</span> + ChronoUnit.DAYS.between(startDate, endDate));</span><br><span class="line"><span class="comment">//        相差月份:1</span></span><br><span class="line"><span class="comment">//        两天之间的差在天数   : 49</span></span><br></pre></td></tr></table></figure><p><strong>注:</strong> ChronoUnit也可以计算相差时分秒。</p><p>示例三：精度时间相差</p><p>Duration 这个类以秒和纳秒为单位建模时间的数量或数量。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Instant</span> <span class="variable">inst1</span> <span class="operator">=</span> Instant.now();</span><br><span class="line">   System.out.println(<span class="string">&quot;当前时间戳 : &quot;</span> + inst1);</span><br><span class="line">   <span class="type">Instant</span> <span class="variable">inst2</span> <span class="operator">=</span> inst1.plus(Duration.ofSeconds(<span class="number">10</span>));</span><br><span class="line">   System.out.println(<span class="string">&quot;增加之后的时间 : &quot;</span> + inst2);</span><br><span class="line">   System.out.println(<span class="string">&quot;相差毫秒 : &quot;</span> + Duration.between(inst1, inst2).toMillis());</span><br><span class="line">   System.out.println(<span class="string">&quot;相毫秒 : &quot;</span> + Duration.between(inst1, inst2).getSeconds());</span><br><span class="line"><span class="comment">// 当前时间戳 : 2018-12-19T08:14:21.675Z</span></span><br><span class="line"><span class="comment">// 增加之后的时间 : 2018-12-19T08:14:31.675Z</span></span><br><span class="line"><span class="comment">// 相差毫秒 : 10000</span></span><br><span class="line"><span class="comment">// 相毫秒 : 10</span></span><br></pre></td></tr></table></figure><p>示例四：时间大小比较</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">LocalDateTime</span> <span class="variable">ldt4</span> <span class="operator">=</span> LocalDateTime.now();</span><br><span class="line"><span class="type">LocalDateTime</span> <span class="variable">ldt5</span> <span class="operator">=</span> ldt4.plusMinutes(<span class="number">10</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;当前时间是否大于:&quot;</span>+ldt4.isAfter(ldt5));</span><br><span class="line">System.out.println(<span class="string">&quot;当前时间是否小于&quot;</span>+ldt4.isBefore(ldt5));</span><br><span class="line"><span class="comment">// false</span></span><br><span class="line"><span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>7.时区时间计算</p><p>得到其他时区的时间。</p><p>示例一:通过Clock时钟类获取计算</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Clock时钟类用于获取当时的时间戳，或当前时区下的日期时间信息。</span><br><span class="line"></span><br><span class="line">  <span class="type">Clock</span> <span class="variable">clock</span> <span class="operator">=</span> Clock.systemUTC();</span><br><span class="line">  System.out.println(<span class="string">&quot;当前时间戳 : &quot;</span> + clock.millis());</span><br><span class="line">  <span class="type">Clock</span> <span class="variable">clock2</span> <span class="operator">=</span> Clock.system(ZoneId.of(<span class="string">&quot;Asia/Shanghai&quot;</span>));</span><br><span class="line">  System.out.println(<span class="string">&quot;亚洲上海此时的时间戳:&quot;</span>+clock2.millis());</span><br><span class="line">  <span class="type">Clock</span> <span class="variable">clock3</span> <span class="operator">=</span> Clock.system(ZoneId.of(<span class="string">&quot;America/New_York&quot;</span>));</span><br><span class="line">  System.out.println(<span class="string">&quot;美国纽约此时的时间戳:&quot;</span>+clock3.millis());</span><br><span class="line">  <span class="comment">//  当前时间戳 : 1545209277657</span></span><br><span class="line">  <span class="comment">//  亚洲上海此时的时间戳:1545209277657</span></span><br><span class="line">  <span class="comment">//  美国纽约此时的时间戳:1545209277658</span></span><br></pre></td></tr></table></figure><p>示例二: 通过ZonedDateTime类和ZoneId</p><pre><code class="java">  ZoneId zoneId= ZoneId.of(&quot;America/New_York&quot;);  ZonedDateTime dateTime=ZonedDateTime.now(zoneId);  System.out.println(&quot;美国纽约此时的时间 : &quot; + dateTime.format(DateTimeFormatter.ofPattern(&quot;yyyy-MM-dd HH:mm:ss.SSS&quot;)));  System.out.println(&quot;美国纽约此时的时间 和时区: &quot; + dateTime);  //  美国纽约此时的时间 : 2018-12-19 03:52:22.494  // 美国纽约此时的时间 和时区: 2018-12-19T03:52:22.494-05:00[America/New_York]</code></pre><h3 id="Java-8日期时间API总结"><a href="#Java-8日期时间API总结" class="headerlink" title="Java 8日期时间API总结:"></a>Java 8日期时间API总结:</h3><ul><li>提供了javax.time.ZoneId 获取时区。</li><li>提供了LocalDate和LocalTime类。</li><li>Java 8 的所有日期和时间API都是不可变类并且线程安全，而现有的Date和Calendar API中的java.util.Date和SimpleDateFormat是非线程安全的。</li><li>主包是 java.time,包含了表示日期、时间、时间间隔的一些类。里面有两个子包java.time.format用于格式化， java.time.temporal用于更底层的操作。</li><li>时区代表了地球上某个区域内普遍使用的标准时间。每个时区都有一个代号，格式通常由区域&#x2F;城市构成（Asia&#x2F;Tokyo），在加上与格林威治或 UTC的时差。例如：东京的时差是+09:00。</li><li>OffsetDateTime类实际上组合了LocalDateTime类和ZoneOffset类。用来表示包含和格林威治或UTC时差的完整日期（年、月、日）和时间（时、分、秒、纳秒）信息。<br>DateTimeFormatter 类用来格式化和解析时间。与SimpleDateFormat不同，这个类不可变并且线程安全，需要时可以给静态常量赋值。DateTimeFormatter类提供了大量的内置格式化工具，同时也允许你自定义。在转换方面也提供了parse()将字符串解析成日期，如果解析出错会抛出DateTimeParseException。DateTimeFormatter类同时还有format()用来格式化日期，如果出错会抛出DateTimeException异常。</li><li>再补充一点，日期格式“MMM d yyyy”和“MMM dd yyyy”有一些微妙的不同，第一个格式可以解析“Jan 2 2014”和“Jan 14 2014”，而第二个在解析“Jan 2 2014”就会抛异常，因为第二个格式里要求日必须是两位的。如果想修正，你必须在日期只有个位数时在前面补零，就是说“Jan 2 2014”应该写成 “Jan 02 2014”。</li></ul><p>来源：<a href="blog.csdn.net/agonie201218/article/details/109199560">blog.csdn.net&#x2F;agonie201218&#x2F;article&#x2F;details&#x2F;109199560</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>String... 传递多个参数</title>
      <link href="/2024/02/25/String-%E4%BC%A0%E9%80%92%E5%A4%9A%E4%B8%AA%E5%8F%82%E6%95%B0/"/>
      <url>/2024/02/25/String-%E4%BC%A0%E9%80%92%E5%A4%9A%E4%B8%AA%E5%8F%82%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<p>String… 类型代表传递0个或多个参数，称为可变长度参数列表，在Java5后支持。</p><p>例如我们有一个方法叫做test(String…strings)，那么你还可以写方法test()，但你不能写test(String[] strings)，这样会出编译错误，系统提示出现重复的方法。</p><p>如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test003</span> &#123;    </span><br><span class="line">      </span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Test003</span><span class="params">()</span>&#123;    </span><br><span class="line">        test();    </span><br><span class="line">        test(<span class="keyword">new</span> <span class="title class_">String</span>[]&#123;<span class="string">&quot;aaa&quot;</span>,<span class="string">&quot;bbb&quot;</span>&#125;);    </span><br><span class="line">        test(<span class="string">&quot;ccc&quot;</span>);    </span><br><span class="line">    &#125;    </span><br><span class="line">        </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span>&#123;    </span><br><span class="line">        System.out.println(<span class="string">&quot;test&quot;</span>);     </span><br><span class="line">    &#125;    </span><br><span class="line">        </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">(String...strings)</span>&#123;    </span><br><span class="line">        <span class="keyword">for</span>(String str:strings)&#123;    </span><br><span class="line">            System.out.print(str + <span class="string">&quot;, &quot;</span>);    </span><br><span class="line">        &#125;    </span><br><span class="line">        System.out.println();    </span><br><span class="line">    &#125;    </span><br><span class="line">        </span><br><span class="line">    <span class="comment">/*private void test(String[] strings)&#123;  </span></span><br><span class="line"><span class="comment">        System.out.println(3);  </span></span><br><span class="line"><span class="comment">          </span></span><br><span class="line"><span class="comment">    &#125;*/</span>    </span><br><span class="line">        </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;    </span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Test003</span>();    </span><br><span class="line">    &#125;    </span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>参考资料：</p></blockquote><ul><li><a href="https://www.cnblogs.com/abc8023/p/6322289.html">程序媛说事儿：【死磕jeestie源码】类型后面三个点(String…)和数组(String[])的区别</a></li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Stream forEach中的remove()空指针异常</title>
      <link href="/2024/02/25/Stream-forEach%E4%B8%AD%E7%9A%84remove-%E7%A9%BA%E6%8C%87%E9%92%88%E5%BC%82%E5%B8%B8/"/>
      <url>/2024/02/25/Stream-forEach%E4%B8%AD%E7%9A%84remove-%E7%A9%BA%E6%8C%87%E9%92%88%E5%BC%82%E5%B8%B8/</url>
      
        <content type="html"><![CDATA[<p>今天在使用Java Stream 流forEach()时，在其中使用了<code>list.remove()</code>的方法，遇到了一些问题，报错空指针异常，业务代码类似以下的逻辑：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;P&gt; <span class="title function_">test</span><span class="params">()</span>&#123;</span><br><span class="line">        List&lt;P&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="type">P</span> <span class="variable">p1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">P</span>(<span class="string">&quot;张三&quot;</span>, <span class="number">20</span>);</span><br><span class="line">        <span class="type">P</span> <span class="variable">p2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">P</span>(<span class="string">&quot;李四&quot;</span>, <span class="number">20</span>);</span><br><span class="line">        list.add(p1);</span><br><span class="line">        list.add(p2);</span><br><span class="line">        <span class="comment">// stream forEach</span></span><br><span class="line">        list.stream().forEach(p -&gt; &#123;</span><br><span class="line">            System.out.println(p.getName());</span><br><span class="line">            <span class="keyword">if</span>(p.getName().equals(<span class="string">&quot;张三&quot;</span>))&#123;</span><br><span class="line">                list.remove(p);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        System.out.println(list.size());</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>大家可以感觉一下这个会不会把张三去掉，李四留下来。</p><p>答案是：<strong>不会</strong>，会全部清空，并且报错。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 输出结果应该是：</span></span><br><span class="line">java.lang.NullPointerException...</span><br><span class="line">张三</span><br></pre></td></tr></table></figure><p>看了一下菜鸟教程中对 <a href="https://www.runoob.com/java/java8-streams.html">Stream流</a> 的介绍，Stream会将列表的数据全部以流的形式进行操作，流在管道中传输，并且在管道中的节点中进行相应的处理。而此时若像上述代码一样执行<code>list.remove(d)</code>，移除的将不是列表中的某一个数据，而是一个整体的流数据。下一次的传入forEach中的值，就是null了，会出现空指针异常。</p><blockquote><p>参考资料：</p><ul><li><a href="https://www.runoob.com/java/java8-streams.html">菜鸟教程：Stream流</a></li></ul></blockquote>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>达梦数据库DCA培训总结</title>
      <link href="/2024/02/25/%E8%BE%BE%E6%A2%A6%E6%95%B0%E6%8D%AE%E5%BA%93DCA%E5%9F%B9%E8%AE%AD%E6%80%BB%E7%BB%93/"/>
      <url>/2024/02/25/%E8%BE%BE%E6%A2%A6%E6%95%B0%E6%8D%AE%E5%BA%93DCA%E5%9F%B9%E8%AE%AD%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<h1 id="达梦数据库DCA培训问题总结"><a href="#达梦数据库DCA培训问题总结" class="headerlink" title="达梦数据库DCA培训问题总结"></a>达梦数据库DCA培训问题总结</h1><p>最近参加了达梦E学举办的——达梦数据库DCA培训考试，在学习过程以及考试期间，曾遇到了一些问题。本文将其中的一些典型问题和知识点加以总结，希望能对大家学习达梦数据库有一定的帮助作用。</p><h2 id="一、安装中遇到的问题"><a href="#一、安装中遇到的问题" class="headerlink" title="一、安装中遇到的问题"></a>一、安装中遇到的问题</h2><p>根据老师提供的指导文档，实验时需要安装VMWare虚拟机以及Linux操作系统。本文以Kylin操作系统为例，在其中安装DM8。我们创建好规划的安装路径&#x2F;dm8、安装用户dmdba以及所属组dinstall，并执行<code>chown dmdba:dinstall -R /dm8</code>进行授权，然后就可以进行数据库的安装操作了。下面列举了安装过程中遇到的一些典型的问题及解决方法。</p><h3 id="1-虚拟机蓝屏问题"><a href="#1-虚拟机蓝屏问题" class="headerlink" title="1.虚拟机蓝屏问题"></a>1.虚拟机蓝屏问题</h3><p>在安装操作系统之后，虚拟机可能出现蓝屏问题，遇到这种情况可以前往虚拟机首页，编辑虚拟机设置，去掉勾选的打印机设备自动连接等选项加以解决。如下图1-1所示：<br><img src="https://img-blog.csdnimg.cn/1082efaeb7e3489699796ea854564c67.png" alt="图1-1 虚拟机蓝屏问题解决"><br>图1-1 虚拟机蓝屏问题解决</p><h3 id="2-图形化界面调用失败问题"><a href="#2-图形化界面调用失败问题" class="headerlink" title="2.图形化界面调用失败问题"></a>2.图形化界面调用失败问题</h3><p>图形化调用失败问题会是初学者所遇到的主要问题。在使用图形化方式安装达梦数据库或者安装后运行DM8图形化界面时，均有可能出现图形化调用失败的问题。此时可以按照以下步骤解决：</p><p>(1) 在终端执行命令：<code>xhost +</code></p><ul><li>如果执行xhost +失败，原因可能是由于用户频繁切换所导致，可关闭当前会话，重新打开一个终端后再次执行该操作。</li></ul><p>(2) 以root身份执行命令：<code>echo $DISLAY</code></p><ul><li>该命令可以查看root用户下的DISPLAY变量值，同时记下该值。</li></ul><p>(3) 切换到安装DM8的用户下，执行命令：<code>export DISPLAY=:0.0</code>；</p><ul><li>其中:0.0为作者在步骤(2)中查询的值，读者应替换为自己所查出的值，需要注意的是不能忽略掉冒号。</li><li>同时，如果是远程ssh连接，需要在哪台设备上调出图形化窗口，则需要将其ip加入命令中，如：<code>export DISPLAY=192.168.0.10:0.0</code>；</li></ul><p>(4) 需要注意的是，export命令只在当前会话内生效，如果关闭当前会话，在新窗口中需要再次执行上面的命令才能生效。</p><h3 id="3-tmp目录空间大小不足问题"><a href="#3-tmp目录空间大小不足问题" class="headerlink" title="3.tmp目录空间大小不足问题"></a>3.tmp目录空间大小不足问题</h3><p>在数据库安装过程中，由于分配给操作系统的临时目录磁盘空间不足，可能会导致安装报错。如图1-2所示：</p><p><img src="https://img-blog.csdnimg.cn/8d398ab62a1d42a3ab2832625ee61e87.png" alt="图1-2 tmp目录不足报错"><br>图1-2 tmp目录不足报错</p><p>解决该问题的步骤如下：</p><p>(1) 以操作系统管理员身份查看当前tmp目录大小，执行命令：<code>df -h /tmp</code>；</p><p>(2) 以操作系统管理员身份创建其他空间大小足够的临时目录，本文以&#x2F;opt&#x2F;tmp为例：<code>mkdir /opt/tmp</code>；</p><p>(3) 以操作系统管理员身份修改用户权限：<code>chown dmdba:dinstall /opt/tmp</code>；</p><p>(4) 以dmdba身份指定临时目录：<code>export DM_INSTALL_TMPDIR=/opt/tmp</code>；</p><h2 id="二、创建实例相关问题"><a href="#二、创建实例相关问题" class="headerlink" title="二、创建实例相关问题"></a>二、创建实例相关问题</h2><p>在创建实例的过程中，大家也会遇到一些典型问题，这些问题也特别容易被大家忽视，从而引起一些不必要的麻烦。以下列举了一些在创建实例的过程中可能遇到的问题。</p><p><strong>1. 创建实例时指定日志文件大小</strong></p><p>创建实例成功后，若需要再次对日志大小进行修改，将只能改大不能改小，用户创建实例时建议不要设置过大的日志文件大小。</p><p><strong>2. 操作系统用户身份验证</strong></p><p>DM8默认没有开启操作系统用户身份验证模式。如果开启了操作系统用户验证方式，可以使用操作系统用户身份验证模式登录，用户应牢记设置的用户密码。</p><p><strong>3. 实例启停方式</strong></p><p>实例的启停方式有两种，一种是使用在成功创建实例服务后在达梦数据库安装目录下的bin目录内生成的实例服务脚本进行启动，另一种是使用系统自带的systemctl命令进行启动。</p><p>(1) 使用bin目录下命令，操作DM8下相应实例服务，如：<code>/dm8/bin/DMTESTSERVER start/stop/status</code>；</p><p>(2) 使用系统命令操作DM8相应实例服务，如：<code>systemctl DMTESTSERVER stop/start/status</code>；</p><p>上述两种方式都可以对实例服务进行操作，但是二者<strong>不可混用</strong>，应当<strong>使用同一组命令对同一实例服务</strong>进行启停操作。</p><p><strong>4. 使用命令创建实例中的问题</strong></p><p>(1) 使用 dminit命令创建数据库实例后，系统不会自动注册实例服务，不能直接用systemctl start 启动数据库服务，应当运行达梦数据库安装目录下的bin目录中的dmserver程序进行启动，如：<code>/dm8/bin/dmserver /dm8/data/DMTEST/dm.ini</code>；</p><p>(2) 可以调用达梦数据库安装目录（&#x2F;dm8）下的tool目录中的dbca.sh来启动图形化数据库配置管理工具，注册数据库服务；</p><p>(3) 可以通过命令行方式注册数据库服务，命令行方式脚本程序所在路径为：&#x2F;dm8&#x2F;script&#x2F;root&#x2F;dm_service_installer.sh，执行如下命令可以注册数据库服务：<code>./dm_service_installer.sh -t dmserver -p DMDASVR -dm_ini /dm8/data/DMDA/dm.ini</code>，如图2-1所示：<br><img src="https://img-blog.csdnimg.cn/ad67cd97223c4c7585e61455ac180715.png" alt="图2-1 注册数据库服务"><br>图2-1 注册数据库服务</p><h2 id="三、其他问题"><a href="#三、其他问题" class="headerlink" title="三、其他问题"></a>三、其他问题</h2><h4 id="1-防火墙相关问题"><a href="#1-防火墙相关问题" class="headerlink" title="1. 防火墙相关问题"></a>1. 防火墙相关问题</h4><p>当启动数据库服务后，通过其他设备连接到该设备中的数据库时，如果无法连接到数据库，则有可能是因为启用防火墙而导致的无法访问数据库。可以通过如下方式进行解决：</p><p><strong>(1) 直接关闭防火墙</strong></p><p>可以通过关闭防火墙来解决该问题，但是对整体系统来讲会有一定的安全隐患，因此不建议在实际工程项目中使用该方法。</p><p><strong>(2) 在防火墙中开放端口</strong></p><p>首先，依次执行以下命令，如图3-1所示：</p><pre><code>a) systemctl stop firewalld；b) systemctl start firewalld；c) firewall-cmd --zone=public --add-port=5236/tcp --permanent；</code></pre><p><img src="https://img-blog.csdnimg.cn/42416268acdc4e4b852480d1885206f7.png" alt="图3-1 开放防火墙中某端口"><br>图3-1 开放防火墙中某端口</p><p>最后，重载与查看防火墙当前端口状态，依次执行以下命令，如图3-2所示：</p><pre><code>a) firewall-cmd --reload；b) firewall-cmd --list-ports；</code></pre><p><img src="https://img-blog.csdnimg.cn/6615f30294144b788b0ec3409be41008.png" alt="图3-2 重载防火墙配置与查看开放端口"><br>图3-2 重载防火墙配置与查看开放端口</p><h4 id="2-调用图形化界面报错"><a href="#2-调用图形化界面报错" class="headerlink" title="2.调用图形化界面报错"></a>2.调用图形化界面报错</h4><p>在调用manager等图形化界面时，会报错（核心已转储），如下图4-1所示，其原因是对变量DISPLAY值未正确设置，可以参照标题一中的第2点，对图形化界面的调用进行重新设置。<br><img src="https://img-blog.csdnimg.cn/c800a38a546049cb857cec8b59ab5a00.png" alt="图4-1 调用图形化界面失败"><br>图4-1 调用图形化界面失败</p><h4 id="3-对数据库进行归档操作后报错"><a href="#3-对数据库进行归档操作后报错" class="headerlink" title="3.对数据库进行归档操作后报错"></a>3.对数据库进行归档操作后报错</h4><p>对数据库进行归档操作后，再次对数据库进行操作时，可能出现（归档点不连续）的问题，可以直接在manager管理界面内执行：checkpoint(100)，即可解决该问题。</p><h4 id="4-建表操作后，点击左侧导航栏时报错"><a href="#4-建表操作后，点击左侧导航栏时报错" class="headerlink" title="4.建表操作后，点击左侧导航栏时报错"></a>4.建表操作后，点击左侧导航栏时报错</h4><p>在新建数据表后，再次点击管理页面左侧导航栏时，会出现报错提醒。这时，需要在管理工具界面的选项设置中，勾选上与导航树有关的相应设置，如下图3-3所示：<br><img src="https://img-blog.csdnimg.cn/c2556cff59564234b16234f968268147.png" alt="图3-3 解决左侧导航栏点击报错问题"><br>图3-3 解决左侧导航栏点击报错问题</p><h4 id="5-联机日志相关问题"><a href="#5-联机日志相关问题" class="headerlink" title="5.联机日志相关问题"></a>5.联机日志相关问题</h4><p>达梦数据库的联机日志，主要存放数据库的REDO信息，默认是两个联机日志文件，循环使用。并且联机日志文件不支持手工切换，由系统自动维护，且不提供对外的删除接口。除此之外，如果需要修改日志文件大小，应当注意的是，在实例创建成功后，已经创建好的日志文件只能改大不能改小。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Cron表达式</title>
      <link href="/2024/02/25/Cron%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
      <url>/2024/02/25/Cron%E8%A1%A8%E8%BE%BE%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h1 id="Cron表达式"><a href="#Cron表达式" class="headerlink" title="Cron表达式"></a>Cron表达式</h1><p>接触cron表达式是在Sping boot定时任务中，cron表达式代表了一个时间，可在定时任务中代表任务的执行执行周期。</p><h2 id="组成"><a href="#组成" class="headerlink" title="组成"></a>组成</h2><p>cron表达式一般由5个或者6个空格组成，组成6或者7个域，每个与中由一些数字&#x2F;符号按照一定规则组成。这组字符串中表达了时间的信息。</p><p>每个域分别代表一个时间单位，如：</p><pre><code>A B C D E F   -&gt;   秒 分 时 日 月 星期A B C D E F G   -&gt;   秒 分 时 日 月 星期 年</code></pre><p><font color=red>A表示秒，B表示分，C表示小时，D表示日，E表示月，F表示星期，G表示年</font><br>在日常的使用中，年为单位执行任务不常用，因此G也可以省略</p><h2 id="常用符号"><a href="#常用符号" class="headerlink" title="常用符号"></a>常用符号</h2><table><thead><tr><th>符号</th><th>含义</th></tr></thead><tbody><tr><td>x&#x2F;y</td><td>x代表开始值，y是步长，即从x开始，每y执行一次</td></tr><tr><td>A-B</td><td>从时间段A到B</td></tr><tr><td>星期</td><td>星期英文前三个字母大写，如星期一 MON</td></tr><tr><td>L</td><td>Last，表示最后</td></tr><tr><td>?</td><td>不说明是星期几，用问号代替</td></tr><tr><td>a,b</td><td>逗号表示列表值</td></tr><tr><td>*</td><td>每</td></tr></tbody></table><h2 id="程序中调用方式"><a href="#程序中调用方式" class="headerlink" title="程序中调用方式"></a>程序中调用方式</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span>      </span><br><span class="line"><span class="meta">@EnableScheduling</span>   </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SaticScheduleTask</span> &#123;</span><br><span class="line">    <span class="meta">@Scheduled(cron = &quot;0/5 * * * * ?&quot;)</span></span><br><span class="line">    <span class="comment">// 或直接指定时间间隔，例如：5秒</span></span><br><span class="line">    <span class="comment">// @Scheduled(fixedRate=5000)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">configureTasks</span><span class="params">()</span> &#123;</span><br><span class="line">        . . .</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>@Configuration</code>表示这是一个配置类，兼备Component的效果。</li><li><code>@EnableScheduling</code>表示开启定时任务。</li><li><code>@Scheduled(cron = &quot;0/5 * * * * ?&quot;)</code>表示添加定时任务——每隔五秒触发事件。</li></ul><h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1949年10月1日下午3点，开国大典时间</span></span><br><span class="line"><span class="number">0</span> <span class="number">0</span> <span class="number">15</span> <span class="number">1</span> <span class="number">10</span> * <span class="number">1949</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 每2小时第30分0秒执行</span></span><br><span class="line"><span class="number">0</span> <span class="number">30</span> */<span class="number">2</span> * * ?</span><br><span class="line"></span><br><span class="line"><span class="comment">// 每个月最后一天的1到5点，然后这几个点内的每个0分1秒，0分3秒，0分5秒各执行一次。</span></span><br><span class="line"><span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span> <span class="number">0</span> <span class="number">1</span>-<span class="number">5</span> L * ?</span><br></pre></td></tr></table></figure><h2 id="Linux中的crontab命令"><a href="#Linux中的crontab命令" class="headerlink" title="Linux中的crontab命令"></a>Linux中的crontab命令</h2><blockquote><p>可参考 <a href="https://www.runoob.com/linux/linux-comm-crontab.html">菜鸟教程：Linux crontab 命令 </a></p></blockquote><p>在Linux中的crontab命令与上述有所不同，更加精简，由五部分+命令（command）组成</p><pre><code>A B C D E command</code></pre><p><font color=red>其中 A 是表示分钟，B 表示小时，C 表示一个月份中的第几日，D 表示月份，E 表示一个星期中的第几天</font></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 每一分钟执行一次 /bin/ls</span></span><br><span class="line">* * * * * /bin/ls      </span><br><span class="line"></span><br><span class="line"><span class="comment">// 在 12 月内, 每天的早上 6 点到 12 点，每隔 3 个小时 0 分钟执行一次 /usr/bin/backup</span></span><br><span class="line"><span class="number">0</span> <span class="number">6</span>-<span class="number">12</span>/<span class="number">3</span> * <span class="number">12</span> * /usr/bin/backup    </span><br><span class="line"></span><br><span class="line"><span class="comment">// 周一到周五每天下午 5:00 寄一封信给 alex@domain.name</span></span><br><span class="line"><span class="number">0</span> <span class="number">17</span> * * <span class="number">1</span>-<span class="number">5</span> mail -s <span class="string">&quot;hi&quot;</span> alex<span class="meta">@domain</span>.name &lt; /tmp/maildata</span><br><span class="line"></span><br><span class="line"><span class="comment">// 每月每天的午夜 0 点 20 分, 2 点 20 分, 4 点 20 分....执行 echo &quot;haha&quot;：</span></span><br><span class="line"><span class="number">20</span> <span class="number">0</span>-<span class="number">23</span>/<span class="number">2</span> * * * echo <span class="string">&quot;haha&quot;</span></span><br></pre></td></tr></table></figure><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ol><li><a href="https://blog.csdn.net/sunnyzyq/article/details/98597252">一看就懂：cron 表达式</a></li><li><a href="https://zhuanlan.zhihu.com/p/450180727">【周一通勤电台】cron表达式，看这篇就够了</a></li><li><a href="https://cron.qqe2.com/">在线Cron表达式生成器</a></li><li><a href="https://www.runoob.com/linux/linux-comm-crontab.html">菜鸟教程：Linux crontab 命令 </a></li></ol>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Spring Bean 相关记录</title>
      <link href="/2024/02/20/Spring-Bean-%E7%9B%B8%E5%85%B3%E8%AE%B0%E5%BD%95/"/>
      <url>/2024/02/20/Spring-Bean-%E7%9B%B8%E5%85%B3%E8%AE%B0%E5%BD%95/</url>
      
        <content type="html"><![CDATA[<h2 id="创建Bean的六种方式"><a href="#创建Bean的六种方式" class="headerlink" title="创建Bean的六种方式"></a>创建Bean的六种方式</h2><blockquote><p><a href="https://www.cnblogs.com/lgjlife/p/11060570.html">参考：https://www.cnblogs.com/lgjlife/p/11060570.html</a></p></blockquote><ol><li>Spring XML 配置<ul><li><code>&lt;component-scan /&gt;</code>相关扫描标签</li></ul></li><li>@Component  @Service  @Controller  @Repository<ul><li>使用<code>@Component</code>扫描或者在启动类的根路径或者子路径下</li></ul></li><li>@Bean</li><li>@Import</li><li>ImportSelector、ImportBeanDefinitionRegistrar接口 + @Import创建EnableXXX注解</li><li>创建对象手动注入 通过DefaultListableBeanFactory注入</li></ol><h2 id="Bean-注解全解析"><a href="#Bean-注解全解析" class="headerlink" title="@Bean 注解全解析"></a>@Bean 注解全解析</h2><blockquote><p><a href="https://www.cnblogs.com/cxuanBlog/p/11179439.html">参考：https://www.cnblogs.com/cxuanBlog/p/11179439.html</a></p></blockquote>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>SQL时间戳区间问题</title>
      <link href="/2024/02/20/SQL%E6%97%B6%E9%97%B4%E6%88%B3%E5%8C%BA%E9%97%B4%E9%97%AE%E9%A2%98/"/>
      <url>/2024/02/20/SQL%E6%97%B6%E9%97%B4%E6%88%B3%E5%8C%BA%E9%97%B4%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h1 id="SQL-时间戳区间问题"><a href="#SQL-时间戳区间问题" class="headerlink" title="SQL 时间戳区间问题"></a>SQL 时间戳区间问题</h1><h2 id="问题举例"><a href="#问题举例" class="headerlink" title="问题举例"></a>问题举例</h2><p>如果Table表中有数据</p><table><thead><tr><th>name</th><th>time</th></tr></thead><tbody><tr><td>张三</td><td>2022-01-01 00:00:00</td></tr><tr><td>李四</td><td>2022-01-01 08:00:00</td></tr></tbody></table><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> <span class="keyword">Table</span> <span class="keyword">where</span> <span class="type">time</span> <span class="keyword">between</span> <span class="string">&#x27;2022-01-01&#x27;</span> <span class="keyword">and</span> <span class="string">&#x27;2022-01-01&#x27;</span>；</span><br><span class="line"><span class="operator">/</span><span class="operator">/</span> <span class="keyword">or</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> <span class="keyword">Table</span> <span class="keyword">where</span> <span class="type">time</span> <span class="operator">&gt;=</span> <span class="string">&#x27;2022-01-01&#x27;</span> <span class="keyword">and</span> <span class="type">time</span> <span class="operator">&lt;=</span> <span class="string">&#x27;2022-01-01&#x27;</span>；</span><br></pre></td></tr></table></figure><p>查询出来的数据会是：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">张三 2022-01-01 00:00:00</span><br></pre></td></tr></table></figure><p>不会有李四数据的原因是，如果时间信息中不添加时分秒的信息，则默认的查询范围是从当天的 00:00:00 到 当天的 00:00:00。</p><h2 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h2><p>可以通过添加时分秒信息进行查询，如</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> <span class="keyword">Table</span> <span class="keyword">where</span> <span class="type">time</span> <span class="keyword">between</span> <span class="string">&#x27;2022-01-01 00:00:00&#x27;</span> <span class="keyword">and</span> <span class="string">&#x27;2022-01-01 23:59:59&#x27;</span>；</span><br><span class="line"><span class="operator">/</span><span class="operator">/</span> <span class="keyword">or</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> <span class="keyword">Table</span> <span class="keyword">where</span> <span class="type">time</span> <span class="operator">&gt;=</span> <span class="string">&#x27;2022-01-01 00:00:00&#x27;</span> <span class="keyword">and</span> <span class="type">time</span> <span class="operator">&lt;=</span> <span class="string">&#x27;2022-01-01 23:59:59&#x27;</span>；</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>test</title>
      <link href="/2023/10/20/test/"/>
      <url>/2023/10/20/test/</url>
      
        <content type="html"><![CDATA[<h2 id="TEST"><a href="#TEST" class="headerlink" title="TEST"></a>TEST</h2><ol><li>hexo g </li><li>hexo d</li><li>hexo new <title></li><li>.&#x2F;source&#x2F;_posts</li></ol>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2023/10/15/hello-world/"/>
      <url>/2023/10/15/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
